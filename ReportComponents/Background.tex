\chapter{Background}
In terms of background, there has been some variation in how we structure and write games over the course of their existence. Initially, writing code in assembly was common as this was the preferred interface for the first game consoles. Another option eventually became to write in straight C. These days though, games are primarily written in many different object-oriented programming languages. Object-oriented design is technically not optimal for game development in terms of performance. Instead, some AAA developers who need to squeeze every last inch of performance out of current generation hardware have made use of a separate paradigm called data-oriented design. 

\section{Data-Oriented Design}
There are a fair amount of resources that discuss data-oriented design. This section mostly summarises the key points from an excellent blog post by Noel Llopis on this topic~\cite{noelDOD}.

\subsection{What are the Problems With Object-oriented Design in Games?}
While object-oriented design has become a staple for how modern-day programming is structured, it is not really optimal from a game development perspective. By using object-oriented design, we inherently create some problems due to how modern-day hardware is architectured. One of these problems is cache misses. A cache miss is generally expensive and something that takes a lot of CPU cycles to deal with. The technicalities of this can be found in Richard Fabian's online book on data-oriented design~\cite{fabiancache}. In general though, a lot of object-oriented patterns can easily result in cache misses for games which impacts overall performance. 

The usage of object-oriented design can also be problematic for multithreading. Object-oriented design can lead to a lot of synchronisation which is performance costly and often error-prone. Furthermore, object-oriented patterns can result in a lot of idle time per thread which could have been used for additional processing. 

\subsection{What is Data-oriented Design and How Does it Fix the Problems?} 
Data-oriented design provides a shift in focus from objects to pure data. It focuses on ''The type of the data, how it is laid out in memory, and how it will be read and processed in the game.''~\cite{noelDOD}. This generally consists of decoupling data from logic. This is done by breaking objects into smaller components and grouping components of the same type together for sequential processing. This sequential processing is a lot easier to do when compared to the object-oriented approach of dealing with each object and its related hierarchies in isolation. As a result, data-oriented design works well when we have more than one of something. This is usually the case in games as we for example have many enemies, many obstacles, many attacks and many health bars. 

The grouping of same type components also makes it easier to write parallel code. In this regard, we are mostly dealing with input data, a small function that processes it and some output data (SIMD style instructions). With this approach, there is less need for synchronisation and we can make better use of threads during asynchronous execution.

Data-oriented design provides a fair amount of performance benefits due to how it is structured. The same code is executed over and over in a data-oriented system which results in efficient use of CPU instruction caches. Data caches are also efficiently used since data of the same type are stored in large contiguous blocks for sequential processing. In terms of optimisation, we have to primarily think about data usage and processing at a higher level which can be hard with traditional object-oriented design. 

The structure of data-oriented design also provides some benefits outside of performance. It often results in more modular code as we have to write small functions that simply transform some data. These small functions generally have little dependency on other parts of the code, making them easy to reuse. There is also no need to understand complex hierarchies to understand the basics of the code. 

While data-oriented design provides a large number of benefits it also has one major drawback. It is different from the object-oriented style of programming that has been ingrained in many programmers which means that it takes time to rethink and restructure how we think about code architectures. This transition is easier for developers who are used to writing code in for example straight C as they can be considered to be data-oriented already. While data-oriented design primarily is used for games, there has also been a case for using it in web development~\cite{nikolovDOD}. 

\section{Unity ECS, C\# Job System and Burst}
In standard Unity, we are generally familiar with a component style architecture. In this architecture, we have scenes that consist of GameObjects. These GameObjects contain modular components which can consist of both data and behaviours. In general, GameObjects are rather heavyweight and they come with a Transform component by default. By attaching any sort of component that inherits from MonoBehaviour a GameObject acquires a fair amount of additional overhead. Unity has previously attempted to provide more lightweight versions of GameObjects with ScriptableObjects. These are primarily used as small data containers, potentially with some behavioural code. Regardless, everything is still tied to GameObjects as ScriptableObjects have to be loaded and worked with in a GameObject component. With the introduction of Unity ECS, Job System and Burst the general workflow of Unity has shifted to a more data-oriented approach for those with interest in it. 

\subsection{What is Unity ECS?}
Unity ECS changes how the core workflow in Unity works in order to allow for better performance by default. This is handled by adopting an entity-component-system architecture with data-oriented principles. 

Scenes still exist, although the scene hierarchy currently only supports GameObjects so it has limited use. GameObjects are entirely replaced with Entities which are a more lightweight version of the former. An Entity is ultimately just an id which points to a set of Components. Components in Unity ECS are slightly different from the standard ones. A Component can only contain blittable data~\cite{blittable} and no additional behaviour. Any behavioural code is instead handled by Systems which process groups of component data, following the same principles that we see in data-oriented design. I.e. instead of having three enemy GameObjects with a ''ShootPlayer'' script that runs individually per enemy we now have a single ''ShootPlayerSystem''. This System processes all Entities that contain specified enemy Components.  

This data-oriented approach is by default a fair bit faster than the standard Unity counterpart. It also provides a more suitable environment for multithreading.

\subsection{What is Unity's C\# Job System?}
Unity's new C\# Job System allows developers to write multithreaded code by providing a C\# interface to the engine's native job system which is used internally. The C\# Job System is closely coupled with Unity ECS in order to parallelise Systems, although they can also be used with standard Unity. It attempts to avoid common pitfalls in multithreading by being architectured in a way that avoids race conditions. Specifying System execution order is possible, albeit in a relatively limited fashion. Outside of this, explicit synchronisation is only allowed for jobs within the same System and this is generally discouraged as is forces the main thread to wait. 

The general workflow of writing parallel Systems is relatively similar to working with shaders on a GPU as everything the job uses needs to be declared ahead of time. Interfacing with the outside world from a job is also limited since it executes natively. This GPU style of kernel execution is partly reflected in Unity's new math library~\cite{unitymath} which features more shader-styled syntax. 

\subsection{What is the Burst Compiler?}
The new Burst Compiler allows for highly optimised compilation of C\# jobs from the new Job System. It uses a subset of C\# called '' High-Performance C\#'' and should provide fairly solid performance increases when used. Burst also allows the developer to view the disassembly of their Systems as well as all compiler optimisations that have been passed or failed.

Unity Technologies generally like to say that ''it just works'' whenever you apply the compiler to a job, but in reality it does put some restrictions in place. It is not immediately obvious what these restrictions are, so applying Burst to a job usually consists of a trial and error approach. Applying Burst compilation to a job simply requires one line of code though, so it is fairly easy to check whether it works or not.  

\subsection{The Current State and The Future of ECS Functionality}
In general, it is recommended to use Unity ECS, the C\# Job System and the Burst Compiler in tandem in order to achieve the highest performance gains. Since everything is in early preview, developers are expected to write all Systems by themselves outside of bare-bones graphics and transform management. This means that elements like physics and collisions are currently something you have to implement by yourself. The goal for Unity is to eventually provide an ECS equivalent for everything that exists in the engine today, but it might take a while. 

\section{Resources for Learning About Unity ECS, Job System and Burst}
In order to get an introduction to Unity ECS I would recommend checking out Unity's tutorial page on it~\cite{ecstutorials} as well as the sample and documentation repository~\cite{ecssamples}. As with any documentation or tutorials, these might be slightly outdated from the latest bleeding edge build of ECS, but the core concepts should remain the same. The sample and documentation repository should at least contain the most updated documentation for ECS. In terms of finding discussion and questions on ECS from a developers point of view I would recommend making use of the ''Entity Component System and C\# Job system'' section of the Unity forums~\cite{ecsforums}. For dealing with small details and technicalities it is possible to check out 5argon's blog post on all the current ECS ''Gotchas''~\cite{ecsgotchas}. This blog post was useful for me whenever I was learning to work with ECS, but it might be slightly outdated in terms of ECS syntax so your mileage might vary. 