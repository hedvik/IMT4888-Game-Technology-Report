\chapter{Introduction}
The Unity Engine sees a large amount of usage within the indie, mid-budget and VR portions of the game industry. On the other hand, the usage of Unity is less prevalent for AAA development in comparison with competitors like Unreal. So why does Unity not see as much usage in this field? One of the reasons for this related to performance and the control of it. Large portions of Unity are written in C\# which means that memory management is automated. The garbage collector in C\# can for example create unwanted stutters in places where developers do not want them. Furthermore, Unity does not really have any official support for multithreaded code either. It is possible to write multithreaded code using C\# functionality like \emph{async} and \emph{await}, but this approach is limited as interfacing with the Unity API is only possible on the main thread. 

As a means to deal with this, Unity has recently launched their new Entity Component System (shortened to ''ECS'') in conjunction with an interface to Unity's native job system and the new Burst compiler. The goal with ECS is to provide an alternative data-oriented workflow for developers that focuses on performance by default and allowing the developer to focus their optimisations on the data and its processing. ECS is currently in early preview, but it is planned to release in 2019 according to Unity's latest R/D talk at Unite LA~\cite{unityLARND}. It is not production ready by any means as much of the core functionality is not yet implemented. Regardless, given the focus on ''performance by default'' it would be interesting to see how ECS compares to the standard object-oriented form of Unity. 